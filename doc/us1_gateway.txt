1- créer les ressources nécessaire avec la commande nest g ressources account(nom de la ressource)

2- il faut enregistrer le microservice dans le module concerné(account.module.ts)
	-on rajoute dans le décorateur @Module un import qui recense le microservice ACCOUNT.
	-on définis le nom du microservice , le type de transport, des options (host et port).
	
3- création du type Account qui nous permettra de manipuler les données avec le paradigme objet si besoin.

4-Dans le account.service.ts on injecte le microservice recensé dans le module grâce au décorateur @Inject(dans les paramètres du controller pas dans le corps) ainsi qu'un attribut client de type clientProxy(permet la communication avec une application extérieure )

5- On définis les méthodes dont on a besoin , à savoir, findAll() et findOne().

6- Dans ces méthodes on configure un message qui identifiera la méthode ciblé dans le microservice(const pattern : any ={cmd:'allAccount'}

7- Pour terminer nos méthodes on retourne la méthode send du client injecté dans le service. La gateway peut maintenant communiqué avec le microservice !

8-Pour communiquer avec notre application FRONT (http)
On configure notre controller qui prendra 'account' pour compléter son URI (localhost:3000/account).

9-Pour la méthode qui nous intéresse findOne() on appelle la méthode par le service(account).

10- On utilise la méthode Pipe afin de limiter le nombre de donnée émise avec la méthode take(1), dans ce là on limite a la première valeur reçu(la @param email)

11- on peut souscrire avec la méthode subscribe pour traiter la réponse.

